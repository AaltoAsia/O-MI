// Generated by CoffeeScript 2.1.0
(function() {
  //#####################################################################
  //  Copyright (c) 2015 Aalto University.

  //  Licensed under the 4-clause BSD (the "License");
  //  you may not use this file except in compliance with the License.
  //  You may obtain a copy of the License at top most directory of project.

  //  Unless required by applicable law or agreed to in writing, software
  //  distributed under the License is distributed on an "AS IS" BASIS,
  //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  //  See the License for the specific language governing permissions and
  //  limitations under the License.
  //#####################################################################

  // import WebOmi, add submodule
  var omiExt;

  omiExt = function(WebOmi) {
    var createOdf, my;
    // Sub module for handling omi xml
    my = WebOmi.omi = {};
    // Generic xml string parser
    my.parseXml = function(responseString) {
      var ex, xmlTree;
      if (responseString < 2) {
        return null;
      }
      try {
        xmlTree = new DOMParser().parseFromString(responseString, 'application/xml');
      } catch (error) {
        ex = error;
        // parsererror or FIXME: unsupported?
        xmlTree = null;
        WebOmi.debug("DOMParser xml parsererror or not supported!");
      }
      
      // mozilla parsererror
      if (xmlTree.firstElementChild.nodeName === "parsererror" || (xmlTree == null)) {
        WebOmi.debug("PARSE ERROR:");
        WebOmi.debug("in:", responseString);
        WebOmi.debug("out:", xmlTree);
        xmlTree = null;
      }
      return xmlTree;
    };
    // XML Namespace URIs used in the client
    // (needed because of the use of default namespaces with XPaths)
    my.ns = {
      omi: "http://www.opengroup.org/xsd/omi/1.0/",
      odf: "http://www.opengroup.org/xsd/odf/1.0/"
    };
    //  xsi : "http://www.w3.org/2001/XMLSchema-instance"
    //  xs  : "http://www.w3.org/......."

    // XML Namespace resolver, (defaults to odf)
    my.nsResolver = function(name) {
      return my.ns[name] || my.ns.odf;
    };
    // Generic Xpath evaluator
    // elem: used as root for relative queries
    // xpath: xpath as string
    my.evaluateXPath = function(elem, xpath) {
      var iter, res, results, xpe;
      xpe = elem.ownerDocument || elem;
      iter = xpe.evaluate(xpath, elem, my.nsResolver, 0, null);
      results = [];
      while (res = iter.iterateNext()) {
        results.push(res);
      }
      return results;
    };
    // private; Create odf element with the right namespace
    // doc: xml document
    // elem: string, odf element name
    createOdf = function(elem, doc) {
      return doc.createElementNS(my.ns.odf, elem);
    };
    my.createOmi = function(elem, doc) {
      return doc.createElementNS(my.ns.omi, elem);
    };
    my.createOdfValue = function(doc, value = null, valueType = null, valueTime = null) {
      var odfVal;
      odfVal = createOdf("value", doc);
      if (value != null) {
        odfVal.appendChild(doc.createTextNode(value));
      }
      if (valueType != null) {
        odfVal.setAttribute("type", "xs:" + valueType);
      }
      if (valueTime != null) {
        odfVal.setAttribute("unixTime", valueTime);
      }
      return odfVal;
    };
    my.createOdfMetaData = function(doc) {
      return createOdf("MetaData", doc);
    };
    my.createOdfDescription = function(doc, text) {
      var descElem, textElem;
      descElem = createOdf("description", doc);
      if (text != null) {
        textElem = doc.createTextNode(text);
        descElem.appendChild(textElem);
      }
      return descElem;
    };
    my.createOdfObjects = function(doc) {
      return createOdf("Objects", doc);
    };
    my.createOdfObject = function(doc, id) {
      var createdElem, idElem, textElem;
      createdElem = createOdf("Object", doc);
      idElem = createOdf("id", doc);
      textElem = doc.createTextNode(id);
      idElem.appendChild(textElem);
      createdElem.appendChild(idElem);
      return createdElem;
    };
    // Create omi element with the right namespace
    // values have structure [{ value:String, valuetime:String unix-time, valuetype:String }]
    my.createOdfInfoItem = function(doc, name, values = [], description = null) {
      var createdElem, i, len, val, value;
      createdElem = createOdf("InfoItem", doc);
      createdElem.setAttribute("name", name);
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        val = my.createOdfValue(doc, value.value, value.type, value.time);
        createdElem.appendChild(val);
      }
      if (description != null) {
        // prepend as first
        createdElem.insertBefore(my.createOdfDescription(doc, description), createdElem.firstChild);
      }
      return createdElem;
    };
    // Gets the id of xmlNode Object or name of InfoItem
    // xmlNode: XmlNode
    // return: Maybe String
    my.getOdfId = function(xmlNode) {
      var head, nameAttr;
      switch (xmlNode.nodeName) {
        case "Object":
          head = my.evaluateXPath(xmlNode, './odf:id')[0];
          if (head != null) {
            return head.textContent.trim();
          } else {
            return null;
          }
          break;
        case "InfoItem":
          nameAttr = xmlNode.attributes.name;
          if (nameAttr != null) {
            return nameAttr.value;
          } else {
            return null;
          }
          break;
        case "Objects":
          return "Objects";
        case "MetaData":
          return "MetaData";
        case "description":
          return "description";
        default:
          return null;
      }
    };
    // Checks if odfNode has odf element child with id or name of odfId
    // odfId: String, object name or infoitem name
    // odfNode: XmlNode, parent of whose children are checked
    // return: Maybe XmlNode
    my.getOdfChild = function(odfId, odfNode) {
      var child, i, len, ref;
      ref = odfNode.childNodes;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (my.getOdfId(child) === odfId) {
          return child;
        }
      }
      return null;
    };
    my.hasOdfChildren = function(odfNode) {
      var child, i, len, maybeId, ref;
      ref = odfNode.childNodes;
      // Could also be made from getOdfChildren
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        maybeId = my.getOdfId(child);
        if ((maybeId != null) && maybeId !== "") {
          return true;
        }
      }
      return false;
    };
    // Return direct Object and InfoItem children of Objects or Object
    // xmlNode: XmlNode
    // return: List XmlNode
    my.getObjectChildren = function(xmlNode) {
      return my.evaluateXPath(xmlNode, './odf:InfoItem | ./odf:Object');
    };
    return WebOmi; // export module
  };

  
  // extend WebOmi
  window.WebOmi = omiExt(window.WebOmi || {});

  window.omi = "ready";

}).call(this);
