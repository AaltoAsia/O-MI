// Generated by CoffeeScript 2.5.1
(function() {
  /*
  Like java, javascript is optimized for throwing null pointer exceptions
  coffeescript helps with its series of ? operators
  but here is a scala option-eqsue "maybe monad" when such semantics
  are preferred over the ? operators or when you want your data
  to self-document its indefinite-ness (regular vars don't warn you
  that you may get null or undefined!).

  note that we're perfectly happy to give you a Some(null) or a Some(undefined)
  just like scala. if you have an x that you want to fmap to None if it's
  null or undefined then use Maybe(x) which will otherwise produce a Some(x)

  Note: scala chose to name fmap 'map' and bind 'flatMap'
    I mention that because fmap is not short for flatMap - a possible confusion.
  */
  var Maybe, None, Some, maybeProto, someProto, sp;

  maybeProto = {
    alert: function() {
      return alert(this.toString());
    },
    log: function() {
      return console.log(this.toString());
    },
    __isMaybe: true
  };

  sp = someProto = Object.create(maybeProto);

  sp.isDefined = sp.nonEmpty = true;

  sp.isEmpty = false;

  sp.toString = function() {
    return `Some(${this.__v})`;
  };

  sp.fmap = function(f) {
    return Maybe(f(this.__v));
  };

  sp.bind = function(f) {
    return f(this.__v);
  };

  sp.exists = sp.forall = sp.bind;

  sp.join = function() {
    if (this.__v.__isMaybe != null) {
      return this.__v;
    } else {
      throw "already flat!";
    }
  };

  sp.getOrElse = sp.get = function() {
    return this.__v;
  };

  sp.toArray = function() {
    return [this.__v];
  };

  Some = function(value) {
    var some;
    some = Object.create(someProto);
    some.__v = value;
    return some;
  };

  //There's only ever one instance of None!
  None = Object.create(maybeProto);

  None.isDefined = None.nonEmpty = false;

  None.isEmpty = true;

  None.toString = function() {
    return "None";
  };

  None.fmap = None.bind = None.join = function() {
    return None; //nice and toxic!
  };

  None.exists = function(f) {
    return false;
  };

  None.forall = function(f) {
    return true;
  };

  None.get = function() {
    throw "called get on none!";
  };

  None.getOrElse = function(x) {
    return x;
  };

  None.toArray = function() {
    return [];
  };

  Maybe = function(value) {
    if (value != null) {
      return Some(value);
    } else {
      return None;
    }
  };

  Maybe.empty = None;

  Maybe.fromArray = function(arr) {
    if (!(arr instanceof Array)) {
      throw "array expected";
    } else {
      switch (arr.length) {
        case 0:
          return None;
        case 1:
          return Some(arr[0]);
        default:
          throw "array length must be 0 or 1";
      }
    }
  };

  //flattens Array of maybes into maybe an array
  //if any of the elements are None then the result will be None
  Maybe.flatten = function(arrOfMaybes) {
    var step;
    step = function(args, arr) {
      switch (args.length) {
        case 0:
          return None;
        //ugly shifts, but I can promise to only call once!
        //I wont let shift hit the fan..
        case 1:
          return args.shift().fmap(function(x) {
            return arr.concat([x]);
          });
        default:
          return args.shift().bind(function(x) {
            return step(args, arr.concat([x]));
          });
      }
    };
    return step(arrOfMaybes, []);
  };

  // usage:
  // Maybe.all(aOpt, bOpt, cOpt, dOpt, eOpt)((a, b, c, d, e) -> 
  //   a+b+c+d+e #result
  // )
  // returns Some(result) if all args are Some(x) else None
  Maybe.all = function(...args) {
    return function(f) {
      return Maybe.flatten(args).fmap(function(arr) {
        return f(...arr);
      });
    };
  };

  //export
  [this.None, this.Some, this.Maybe] = [None, Some, Maybe];

  window.maybe = "ready";

}).call(this);
