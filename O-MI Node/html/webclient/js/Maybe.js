// Generated by CoffeeScript 1.12.6

/*
Like java, javascript is optimized for throwing null pointer exceptions
coffeescript helps with its series of ? operators
but here is a scala option-eqsue "maybe monad" when such semantics
are preferred over the ? operators or when you want your data
to self-document its indefinite-ness (regular vars don't warn you
that you may get null or undefined!).

note that we're perfectly happy to give you a Some(null) or a Some(undefined)
just like scala. if you have an x that you want to fmap to None if it's
null or undefined then use Maybe(x) which will otherwise produce a Some(x)

Note: scala chose to name fmap 'map' and bind 'flatMap'
  I mention that because fmap is not short for flatMap - a possible confusion.
 */

(function() {
  var Maybe, None, Some, maybeProto, ref, someProto, sp,
    slice = [].slice;

  maybeProto = {
    alert: function() {
      return alert(this.toString());
    },
    log: function() {
      return console.log(this.toString());
    },
    __isMaybe: true
  };

  sp = someProto = Object.create(maybeProto);

  sp.isDefined = sp.nonEmpty = true;

  sp.isEmpty = false;

  sp.toString = function() {
    return "Some(" + this.__v + ")";
  };

  sp.fmap = function(f) {
    return Maybe(f(this.__v));
  };

  sp.bind = function(f) {
    return f(this.__v);
  };

  sp.exists = sp.forall = sp.bind;

  sp.join = function() {
    if (this.__v.__isMaybe != null) {
      return this.__v;
    } else {
      throw "already flat!";
    }
  };

  sp.getOrElse = sp.get = function() {
    return this.__v;
  };

  sp.toArray = function() {
    return [this.__v];
  };

  Some = function(value) {
    var some;
    some = Object.create(someProto);
    some.__v = value;
    return some;
  };

  None = Object.create(maybeProto);

  None.isDefined = None.nonEmpty = false;

  None.isEmpty = true;

  None.toString = function() {
    return "None";
  };

  None.fmap = None.bind = None.join = function() {
    return None;
  };

  None.exists = function(f) {
    return false;
  };

  None.forall = function(f) {
    return true;
  };

  None.get = function() {
    throw "called get on none!";
  };

  None.getOrElse = function(x) {
    return x;
  };

  None.toArray = function() {
    return [];
  };

  Maybe = function(value) {
    if (value != null) {
      return Some(value);
    } else {
      return None;
    }
  };

  Maybe.empty = None;

  Maybe.fromArray = function(arr) {
    if (!(arr instanceof Array)) {
      throw "array expected";
    } else {
      switch (arr.length) {
        case 0:
          return None;
        case 1:
          return Some(arr[0]);
        default:
          throw "array length must be 0 or 1";
      }
    }
  };

  Maybe.flatten = function(arrOfMaybes) {
    var step;
    step = function(args, arr) {
      switch (args.length) {
        case 0:
          return None;
        case 1:
          return args.shift().fmap(function(x) {
            return arr.concat([x]);
          });
        default:
          return args.shift().bind(function(x) {
            return step(args, arr.concat([x]));
          });
      }
    };
    return step(arrOfMaybes, []);
  };

  Maybe.all = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(f) {
      return Maybe.flatten(args).fmap(function(arr) {
        return f.apply(null, arr);
      });
    };
  };

  ref = [None, Some, Maybe], this.None = ref[0], this.Some = ref[1], this.Maybe = ref[2];

  window.maybe = "ready";

}).call(this);
