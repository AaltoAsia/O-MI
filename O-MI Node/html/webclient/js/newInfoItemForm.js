// Generated by CoffeeScript 2.0.0
(function() {
  //##########################################################################
  //  Copyright (c) 2015 Aalto University.

  //  Licensed under the 4-clause BSD (the "License");
  //  you may not use this file except in compliance with the License.
  //  You may obtain a copy of the License at top most directory of project.

  //  Unless required by applicable law or agreed to in writing, software
  //  distributed under the License is distributed on an "AS IS" BASIS,
  //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  //  See the License for the specific language governing permissions and
  //  limitations under the License.
  //#########################################################################
  // Code for new InfoItem modal popup,
  // which is found with right click in the odf tree and selecting new InfoItem

  // imports
  (function(consts, requests, omi, util) {
    var cloneAbove, createTimestampPicker, findDuplicate, getGroups, notifyErrorOn, readValues, resetInfoItemForm, updateOdf;
    
    // Utility function; Clone the element above and empty its input fields 
    // callback type: (clonedDom) -> void
    cloneAbove = function(target, callback) {
      return util.cloneAbove(target, function(cloned) {
        if (callback != null) {
          callback(cloned);
        }
        return cloned.slideDown(null, function() { // animation, default duration
          // readjusts the position because of size change (see modal docs)
          return consts.infoItemDialog.modal('handleUpdate');
        });
      });
    };
    // Utility; create timestamp picker gui
    createTimestampPicker = function(dom) {
      return dom.find('.timestamp').datetimepicker({
        format: 'X', // NOTE: Current version of datetimepicker does not support unixtime
        // (thinks that month, year and time is not enabled)
        // the required change is to add the following line to isEnabled private function:
        // if (actualFormat.toLowerCase().indexOf('x') !== -1) return true;
        sideBySide: true
      });
    };
    // 4. Resetting
    resetInfoItemForm = function() {
      consts.infoItemForm.replaceWith(consts.originalInfoItemForm.clone());
      consts.infoItemForm = $(consts.infoItemDialog.find('form'));
      // Re-bind events

      // prevent any submitting fix (maybe not needed)
      consts.infoItemForm.submit(function(event) {
        return event.preventDefault();
      });
      consts.infoItemForm.find('.btn-clone-above').on('click', function() {
        return cloneAbove($(this), createTimestampPicker); // creates if there is class .timestamp
      });
      
      // tooltips & popovers also lose some event handlers
      consts.infoItemForm.find('[data-toggle="tooltip"]').tooltip({
        container: 'body'
      });
      // recreate complex ui widgets
      createTimestampPicker(consts.infoItemForm);
    };
    notifyErrorOn = function(jqElement, errorMsg) {
      return jqElement.tooltip({
        placement: "top",
        title: errorMsg
      }).focus().on('input', function() { // triggers the tooltip also
        return $(this).tooltip('destroy').closest('.form-group').removeClass('has-error');
      }).closest('.form-group').addClass('has-error');
    };
    // 1. Input helpers to fill the form
    consts.afterJquery(function() {
      consts.infoItemDialog = $('#newInfoItem');
      consts.infoItemForm = consts.infoItemDialog.find('form');
      consts.originalInfoItemForm = consts.infoItemForm.clone();
      
      // Reset on cancel or close
      consts.infoItemDialog.on('hide.bs.modal', function() {
        return resetInfoItemForm();
      });
      // For binding of events
      resetInfoItemForm();
      consts.infoItemDialog.find('.newInfoSubmit').on('click', function() {
        var infoitemData;
        infoitemData = readValues();
        return updateOdf(infoitemData);
      });
    });
    // 2. Reading of values

    // return an Array of objects extracted from inputs of given selector (:String)
    getGroups = function(ofWhat, requiredField) {
      var arr;
      arr = [];
      consts.infoItemForm.find(ofWhat).each(function() {
        var value;
        value = {};
        $(this).find(":input").each(function() {
          return value[this.name] = $(this).val();
        });
        if ((value[requiredField] != null) && value[requiredField].length > 0) {
          arr.push(value);
        }
      });
      return arr;
    };
    readValues = function() {
      var results;
      results = {};
      consts.infoItemForm.find("#infoItemName, #infoItemDescription, #infoItemParent").each(function() {
        return results[this.name] = $(this).val();
      });
      results.values = getGroups(".value-group", "value");
      results.metadatas = getGroups(".metadata-group", "metadataname");
      return results;
    };
    findDuplicate = function(arr) {
      var i, item, len, set;
      set = {};
      for (i = 0, len = arr.length; i < len; i++) {
        item = arr[i];
        if (set[item] != null) {
          return item;
        } else {
          set[item] = true;
        }
      }
      return null;
    };
    // 3. Generate the odf and update the state
    // takes input in the form which readValues returns
    updateOdf = function(newInfoItem) {
      var duplicateInputs, duplicateTime, idName, metaObj, metas, name, parent, path, tree, v, valueObj, values;
      tree = WebOmi.consts.odfTree;
      parent = newInfoItem.parent;
      name = newInfoItem.name;
      idName = idesc(name);
      path = `${parent}/${idName}`;
      if ($(jqesc(path)).length > 0) { // name already exists, 
        tree.select_node(path);
        // Inform the user
        notifyErrorOn($('#infoItemName')("InfoItem with this name already exists")); // don't close
      } else {
        // TODO: use validators on higher level and set gui indicators (has-success/has-error)
        v = WebOmi.util.validators;
        values = (function() {
          var i, len, ref, results1;
          ref = newInfoItem.values;
          results1 = [];
          for (i = 0, len = ref.length; i < len; i++) {
            valueObj = ref[i];
            results1.push({
              value: valueObj.value,
              type: valueObj.valuetype,
              time: v.nonEmpty(valueObj.valuetime)
            });
          }
          return results1;
        })();
        duplicateTime = findDuplicate(values.map(function(val) {
          return val.time;
        }));
        if (duplicateTime != null) {
          duplicateInputs = $("input[name='valuetime']").filter(function(_, e) {
            return $(e).val() === duplicateTime;
          });
          notifyErrorOn(duplicateInputs, "Server probably doesn't accept multiple values with the same timestamp."); // don't close
          return;
        }
        metas = (function() {
          var i, len, ref, results1;
          ref = newInfoItem.metadatas;
          results1 = [];
          for (i = 0, len = ref.length; i < len; i++) {
            metaObj = ref[i];
            results1.push({
              name: metaObj.metadataname,
              value: metaObj.metadatavalue,
              type: v.nonEmpty(metaObj.metadatatype),
              description: v.nonEmpty(metaObj.metadatadescription)
            });
          }
          return results1;
        })();
        
        // NOTE: This also selects the node which triggers an event which modifies the request 
        consts.addOdfTreeNode(parent, path, name, "infoitem"); //, (node) ->
        // $(jqesc node.id).data "values", values
        //.data "description", v.nonEmpty newInfoItem.description
        consts.addOdfTreeNode(path, path + "/MetaData", "MetaData", "metadata");
        
        //, (node) ->
        //$(jqesc node.id).data "metadatas", metas
        consts.addOdfTreeNode(path, path + "/description", "description", "description");
        
        //, (node) ->
        //$(jqesc node.id).data "description", v.nonEmpty newInfoItem.description
        $(jqesc(path)).data("values", values);
        $(jqesc(path + "/description")).data("description", v.nonEmpty(newInfoItem.description));
        $(jqesc(path + "/MetaData")).data("metadatas", metas);
        tree = WebOmi.consts.odfTree;
        tree.select_node(path);
        if ((v.nonEmpty(newInfoItem.description)) != null) {
          tree.select_node(path + "/description");
        }
        if (metas.length > 0) {
          tree.select_node(path(+"/MetaData"));
        }
        
        // close the dialog
        consts.infoItemDialog.modal('hide');
        // reset
        resetInfoItemForm();
      }
    };
    window.newInfoItemForm = "ready";
  })(WebOmi.consts, WebOmi.requests, WebOmi.omi, WebOmi.util);

}).call(this);
