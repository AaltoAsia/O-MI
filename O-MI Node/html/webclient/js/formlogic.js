// Generated by CoffeeScript 1.10.0
(function() {
  var formLogicExt,
    hasProp = {}.hasOwnProperty;

  formLogicExt = function($, WebOmi) {
    var my;
    my = WebOmi.formLogic = {};
    my.setRequest = function(xml) {
      var mirror;
      mirror = WebOmi.consts.requestCodeMirror;
      if (xml == null) {
        mirror.setValue("");
      } else if (typeof xml === "string") {
        mirror.setValue(xml);
      } else {
        mirror.setValue(new XMLSerializer().serializeToString(xml));
      }
      return mirror.autoFormatAll();
    };
    my.getRequest = function() {
      var str;
      str = WebOmi.consts.requestCodeMirror.getValue();
      return WebOmi.omi.parseXml(str);
    };
    my.modifyRequest = function(callback) {
      var req;
      req = my.getRequest();
      callback();
      return WebOmi.requests.generate();
    };
    my.getRequestOdf = function() {
      var str;
      WebOmi.error("getRequestOdf is deprecated");
      str = WebOmi.consts.requestCodeMirror.getValue();
      return o.evaluateXPath(str, '//odf:Objects')[0];
    };
    my.clearResponse = function() {
      var mirror;
      mirror = WebOmi.consts.responseCodeMirror;
      mirror.setValue("");
      return WebOmi.consts.responseDiv.slideUp();
    };
    my.setResponse = function(xml) {
      var mirror;
      mirror = WebOmi.consts.responseCodeMirror;
      if (typeof xml === "string") {
        mirror.setValue(xml);
      } else {
        mirror.setValue(new XMLSerializer().serializeToString(xml));
      }
      mirror.autoFormatAll();
      WebOmi.consts.responseDiv.slideDown({
        complete: function() {
          return mirror.refresh();
        }
      });
      return mirror.refresh();
    };
    my.handleSubscriptionHistory = function(response) {
      var addHistory, end, getPath, getPathValues, htmlformat, info, infoitemXmls, newHistory, odf, pathValues, requestID, returnStatus, start;
      start = response.search("<omi:requestID>") + 15;
      end = response.search("</omi:requestID>");
      requestID = parseInt(response.slice(start, end));
      start = response.search("<Objects>");
      end = response.search("</Objects>");
      odf = response.slice(start, end);
      infoitemXmls = odf.getElementsByTagName("InfoItem");
      getPath = function(xmlNode) {
        var head, id, init, name, nameAttr;
        switch (xmlNode.nodeName) {
          case "Object":
            head = my.evaluateXPath(xmlNode, './odf:id')[0];
            if (head != null) {
              id = head.textContent.trim();
              init = getPath(xmlNode.parentNode);
              return init + "/" + id;
            } else {
              return null;
            }
            break;
          case "InfoItem":
            nameAttr = xmlNode.attributes.name;
            if (nameAttr != null) {
              name = nameAttr.value;
              init = getPath(xmlNode.parentNode);
              return init + "/" + name;
            } else {
              return null;
            }
            break;
          case "Objects":
            return "Objects";
          default:
            return null;
        }
      };
      getPathValues = function(infoitemXml) {
        var valueXml, valuesXml;
        valuesXml = infoitemXml.getChildsByTagName("value");
        return {
          path: getPath(infoitemXml),
          values: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = valuesXml.length; i < len; i++) {
              valueXml = valuesXml[i];
              results.push(valueXml.textContent);
            }
            return results;
          })()
        };
      };
      pathValues = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = infoitemXmls.length; i < len; i++) {
          info = infoitemXmls[i];
          results.push(getPathValues(info));
        }
        return results;
      })();
      newHistory = function(requestID) {
        return "<div class=\"responseList\" id=\"requestID" + requestID + ">" + "<div class=\"panel panel-info\">" + "<div class=\"panel-heading\">" + "<h3 class=\"panel-title\"><b>RequestID " + requestID + "</b></h3>" + "</div>" + "<table class=\"table table-hover table-condensed\">" + "<thead><tr><th>#</th><th>InfoItem</th><th>value</th></tr></thead>" + "<tbody>" + "</tbody>" + "</table>" + "</div>";
      };
      returnStatus = function(count, returnCode) {
        switch (returnCode) {
          case 200:
            return "<tr class=\"success\"><th>" + count + "</th><th>returnCode</th><th>" + returnCode + "</th></tr>";
          case 404:
            return "<tr class=\"danger\"><th>" + count + "</th><th>returnCode</th><th>" + returnCode + "</th></tr>";
          default:
            return "<tr class=\"danger\"><th>" + count + "</th><th>returnCode</th><th>" + returnCode + "</th></tr>";
        }
      };
      htmlformat = function(pathValues) {
        var i, j, len, len1, lines, pathValue, results, value;
        for (i = 0, len = pathValues.length; i < len; i++) {
          pathValue = pathValues[i];
          lines = (function() {
            var j, len1, ref, results;
            ref = pathValue.values;
            results = [];
            for (j = 0, len1 = ref.length; j < len1; j++) {
              value = ref[j];
              results.push({
                path: pathValue.path,
                value: value
              });
            }
            return results;
          })();
        }
        results = [];
        for (j = 0, len1 = lines.length; j < len1; j++) {
          pathValue = lines[j];
          results.push("<tr><td></td><td>" + pathValue.path + "</td><td>" + pathValue.value + "</td></tr>");
        }
        return results;
      };
      addHistory = function(requestID, pathValues) {
        var requestHistory;
        requestHistory = $("requestID" + requestID);
        if (requestHistory != null) {
          return $("requestID" + requestID + " > table > tbody > tr").prepend((returnStatus(3, 200)) + htmlformat(pathValues));
        } else {
          $(".responseListCollection > .responesList").prepend(newHistory(requestID));
          return $("requestID" + requestID + " > table > tbody").add((returnStatus(1, 200)) + htmlformat(pathValues));
        }
      };
      return addHistory(requestID, pathValues);
    };
    my.createWebSocket = function(onopen, onclose, onmessage, onerror) {
      var consts, server, socket;
      console.log("Creating WebSocket.");
      consts = WebOmi.consts;
      server = consts.serverUrl.val();
      socket = new WebSocket(server);
      socket.onopen = onopen;
      socket.onclose = onclose;
      socket.onmessage = onmessage;
      socket.onerror = onerror;
      return my.socket = socket;
    };
    my.send = function(callback) {
      var consts, request, server;
      consts = WebOmi.consts;
      my.clearResponse();
      server = consts.serverUrl.val();
      request = consts.requestCodeMirror.getValue();
      if (server.startsWith("ws://") || server.startsWith("wss://")) {
        console.log("Sending request via WebSocket.");
        return my.wsSend(request);
      } else {
        console.log("Sending request with HTTP POST.");
        return my.httpSend(callback);
      }
    };
    my.wsSend = function(request) {
      var onclose, onerror, onmessage, onopen;
      if (!my.socket || my.socket.readyState !== WebSocket.OPEN) {
        onopen = function() {
          console.log("WebSocket connected.");
          return my.socket.send(request);
        };
        onclose = function() {
          return console.log("WebSocket disconnected.");
        };
        onerror = function(error) {
          return console.log("WebSocket error: " + error);
        };
        onmessage = my.handleWSMessage;
        return my.createWebSocket(onopen, onclose, onmessage, onerror);
      } else {
        console.log("Sending request via WebSocket.");
        return my.socket.send(request);
      }
    };
    my.httpSend = function(callback) {
      var consts, request, server;
      consts = WebOmi.consts;
      server = consts.serverUrl.val();
      request = consts.requestCodeMirror.getValue();
      consts.progressBar.css("width", "95%");
      return $.ajax({
        type: "POST",
        url: server,
        data: request,
        contentType: "text/xml",
        processData: false,
        dataType: "text",
        error: function(response) {
          consts.progressBar.css("width", "100%");
          my.setResponse(response.responseText);
          consts.progressBar.css("width", "0%");
          consts.progressBar.hide();
          return window.setTimeout((function() {
            return consts.progressBar.show();
          }), 2000);
        },
        success: function(response) {
          consts.progressBar.css("width", "100%");
          my.setResponse(response);
          consts.progressBar.css("width", "0%");
          consts.progressBar.hide();
          window.setTimeout((function() {
            return consts.progressBar.show();
          }), 2000);
          if ((callback != null)) {
            return callback(response);
          }
        }
      });
    };
    my.handleWSMessage = function(message) {
      var consts, response;
      consts = WebOmi.consts;
      response = message.data;
      if (-1 !== response.search("<omi:requestID>") && -1 !== response.search("<Objects>")) {
        return my.handleSubscriptionHistory(response);
      } else {
        consts.progressBar.css("width", "100%");
        my.setResponse(response);
        consts.progressBar.css("width", "0%");
        consts.progressBar.hide();
        return window.setTimeout((function() {
          return consts.progressBar.show();
        }), 2000);
      }
    };
    my.buildOdfTree = function(objectsNode) {
      var evaluateXPath, genData, objChildren, tree, treeData;
      tree = WebOmi.consts.odfTree;
      evaluateXPath = WebOmi.omi.evaluateXPath;
      objChildren = function(xmlNode) {
        return evaluateXPath(xmlNode, './odf:InfoItem | ./odf:Object');
      };
      genData = function(xmlNode, parentPath) {
        var child, name, path;
        switch (xmlNode.nodeName) {
          case "Objects":
            name = xmlNode.nodeName;
            return {
              id: idesc(name),
              text: name,
              state: {
                opened: true
              },
              type: "objects",
              children: (function() {
                var i, len, ref, results;
                ref = objChildren(xmlNode);
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                  child = ref[i];
                  results.push(genData(child, name));
                }
                return results;
              })()
            };
          case "Object":
            name = WebOmi.omi.getOdfId(xmlNode);
            path = parentPath + "/" + name;
            return {
              id: idesc(path),
              text: name,
              type: "object",
              children: (function() {
                var i, len, ref, results;
                ref = objChildren(xmlNode);
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                  child = ref[i];
                  results.push(genData(child, path));
                }
                return results;
              })()
            };
          case "InfoItem":
            name = WebOmi.omi.getOdfId(xmlNode);
            path = parentPath + "/" + name;
            return {
              id: idesc(path),
              text: name,
              type: "infoitem",
              children: [
                genData({
                  nodeName: "MetaData"
                }, path)
              ]
            };
          case "MetaData":
            path = parentPath + "/MetaData";
            return {
              id: idesc(path),
              text: "MetaData",
              type: "metadata",
              children: []
            };
        }
      };
      treeData = genData(objectsNode);
      tree.settings.core.data = [treeData];
      return tree.refresh();
    };
    my.buildOdfTreeStr = function(responseString) {
      var objectsArr, omi, parsed;
      omi = WebOmi.omi;
      parsed = omi.parseXml(responseString);
      objectsArr = omi.evaluateXPath(parsed, "//odf:Objects");
      if (objectsArr.length !== 1) {
        return alert("failed to get single Objects odf root");
      } else {
        return my.buildOdfTree(objectsArr[0]);
      }
    };
    return WebOmi;
  };

  window.WebOmi = formLogicExt($, window.WebOmi || {});

  (function(consts, requests, formLogic) {
    return consts.afterJquery(function() {
      var controls, inputVar, makeRequestUpdater, ref;
      consts.readAllBtn.on('click', function() {
        return requests.readAll(true);
      });
      consts.sendBtn.on('click', function() {
        return formLogic.send();
      });
      consts.resetAllBtn.on('click', function() {
        var child, closetime, i, len, ref;
        requests.forceLoadParams(requests.defaults.empty());
        closetime = 1500;
        ref = consts.odfTree.get_children_dom('Objects');
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          consts.odfTree.close_all(child, closetime);
        }
        return formLogic.clearResponse();
      });
      consts.ui.odf.ref.on("changed.jstree", function(_, data) {
        var odfTreePath;
        switch (data.action) {
          case "select_node":
            odfTreePath = data.node.id;
            return formLogic.modifyRequest(function() {
              return requests.params.odf.add(odfTreePath);
            });
          case "deselect_node":
            odfTreePath = data.node.id;
            formLogic.modifyRequest(function() {
              return requests.params.odf.remove(odfTreePath);
            });
            return $(jqesc(odfTreePath)).children(".jstree-children").find(".jstree-node").each(function(_, node) {
              return consts.odfTree.deselect_node(node, true);
            });
        }
      });
      consts.ui.request.ref.on("select_node.jstree", function(_, data) {
        var i, input, isReadReq, isRequestIdReq, len, readReqWidgets, reqName, ui;
        reqName = data.node.id;
        WebOmi.debug(reqName);
        if (reqName === "readReq") {
          return consts.ui.request.set("read");
        } else {
          ui = WebOmi.consts.ui;
          readReqWidgets = [ui.newest, ui.oldest, ui.begin, ui.end];
          isReadReq = (function() {
            switch (reqName) {
              case "readAll":
              case "read":
              case "readReq":
                return true;
              default:
                return false;
            }
          })();
          isRequestIdReq = (function() {
            switch (reqName) {
              case "cancel":
              case "poll":
                return true;
              default:
                return false;
            }
          })();
          for (i = 0, len = readReqWidgets.length; i < len; i++) {
            input = readReqWidgets[i];
            input.ref.prop('disabled', !isReadReq);
            input.set(null);
            input.ref.trigger("input");
          }
          ui.requestID.ref.prop('disabled', !isRequestIdReq);
          if (!isRequestIdReq) {
            ui.requestID.set(null);
            ui.requestID.ref.trigger("input");
          }
          ui.interval.ref.prop('disabled', reqName !== 'subscription');
          ui.interval.set(null);
          ui.interval.ref.trigger("input");
          return formLogic.modifyRequest(function() {
            var newHasMsg;
            requests.params.name.update(reqName);
            newHasMsg = requests.defaults[reqName]().msg;
            return requests.params.msg.update(newHasMsg);
          });
        }
      });
      makeRequestUpdater = function(input) {
        return function(val) {
          return formLogic.modifyRequest(function() {
            return requests.params[input].update(val);
          });
        };
      };
      ref = consts.ui;
      for (inputVar in ref) {
        if (!hasProp.call(ref, inputVar)) continue;
        controls = ref[inputVar];
        if (controls.bindTo != null) {
          controls.bindTo(makeRequestUpdater(inputVar));
        }
      }
      return null;
    });
  })(window.WebOmi.consts, window.WebOmi.requests, window.WebOmi.formLogic);

  $(function() {
    return $('.optional-parameters > a').on('click', function() {
      var glyph;
      glyph = $(this).find('span.glyphicon');
      if (glyph.hasClass('glyphicon-menu-right')) {
        glyph.removeClass('glyphicon-menu-right');
        return glyph.addClass('glyphicon-menu-down');
      } else {
        glyph.removeClass('glyphicon-menu-down');
        return glyph.addClass('glyphicon-menu-right');
      }
    });
  });

}).call(this);
